{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Prelude","text":""},{"location":"#overview","title":"Overview","text":"<p>This package extends the FastAPI response model schema allowing you to have a common response wrapper via a <code>fastapi.routing.APIRoute</code>.</p> <p>This library supports Python versions &gt;=3.8 and FastAPI versions &gt;=0.89.1.</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#install-the-package","title":"Install the package","text":"<pre><code>pip install fastapi-responseschema\n</code></pre> <p>If you are planning to use the pagination integration, you can install the package including fastapi-pagination <pre><code>pip install fastapi-responseschema[pagination]\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<pre><code>from typing import Generic, TypeVar, Any, Optional, List\nfrom pydantic import BaseModel\nfrom fastapi import FastAPI\nfrom fastapi_responseschema import AbstractResponseSchema, SchemaAPIRoute, wrap_app_responses\n\n\n# Build your \"Response Schema\"\nclass ResponseMetadata(BaseModel):\n    error: bool\n    message: Optional[str]\n\n\nT = TypeVar(\"T\")\n\n\nclass ResponseSchema(AbstractResponseSchema[T], Generic[T]):\n    data: T\n    meta: ResponseMetadata\n\n    @classmethod\n    def from_exception(cls, reason, status_code, message: str = \"Error\", **others):\n        return cls(\n            data=reason,\n            meta=ResponseMetadata(error=status_code &gt;= 400, message=message)\n        )\n\n    @classmethod\n    def from_api_route(\n        cls, content: Any, status_code: int, description: Optional[str] = None, **others\n    ):\n        return cls(\n            data=content,\n            meta=ResponseMetadata(error=status_code &gt;= 400, message=description)\n        )\n\n\n# Create an APIRoute\nclass Route(SchemaAPIRoute):\n    response_schema = ResponseSchema\n\n# Integrate in FastAPI app\napp = FastAPI()\nwrap_app_responses(app, Route)\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n@app.get(\"/items\", response_model=List[Item], description=\"This is a route\")\ndef get_operation():\n    return [Item(id=1, name=\"ciao\"), Item(id=2, name=\"hola\"), Item(id=3, name=\"hello\")]\n</code></pre> <p>Te result of <code>GET /items</code>: <pre><code>HTTP/1.1 200 OK\ncontent-length: 131\ncontent-type: application/json\n\n{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"ciao\"\n        },\n        {\n            \"id\": 2,\n            \"name\": \"hola\"\n        },\n        {\n            \"id\": 3,\n            \"name\": \"hello\"\n        }\n    ],\n    \"meta\": {\n        \"error\": false,\n        \"message\": \"This is a route\"\n    }\n}\n</code></pre></p>"},{"location":"contributing/","title":"Contibuting","text":""},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>Just open an issue or submit a pull request on GitHub.</p> <p>While submitting a pull request describe what changes have been made.</p> <p>More info on Docs section</p>"},{"location":"contributing/#contributors-wall","title":"Contributors Wall","text":""},{"location":"contributing/#guidelines","title":"Guidelines","text":"<ul> <li>Try to adhere as much as possible to the Python style and language conventions.</li> <li>Add unit tests for classes and methods. </li> <li>When writing features exposed in API, always add documentation following the Google Style Python docstrings.</li> </ul>"},{"location":"contributing/#enviroment","title":"Enviroment","text":"<p>This package is developed using Python version <code>3.8</code>.</p> <p>This package uses poetry to handle dependencies, you can install them with: <pre><code>poetry install -E pagination\n</code></pre></p>"},{"location":"contributing/#formatting","title":"Formatting","text":"<p>Black is used to provide code autoformatting e linting. Before committing your changes run <code>black</code>: <pre><code>black .\n</code></pre></p>"},{"location":"contributing/#type-checking","title":"Type checking","text":"<p>mypy is used to statically type check the source code. Before committing your changes run <code>mypy</code>: <pre><code>mypy fastapi_responseschema\n</code></pre></p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Tests are written using pytest. To run the test suite just type in your terminal: <pre><code>pytest\n</code></pre> This will generate the coverage in html format in a root level directory <code>htmlcov</code>.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is built using pydoc-markdown. To run the documentation dev server: <pre><code>novella -d docs --serve\n</code></pre> To build the docs: <pre><code>novella -d docs\n</code></pre></p>"},{"location":"api/exceptions/","title":"Exceptions (<code>fastapi_responseschema.exceptions</code>)","text":""},{"location":"api/exceptions/#class-basegenerichttpexception","title":"Class BaseGenericHTTPException","text":"<pre><code>class BaseGenericHTTPException(FastAPIHTTPException)\n</code></pre> <p>[view_source]</p> <p>BaseClass for HTTPExceptions with additional data</p> <p></p> <p></p>"},{"location":"api/exceptions/#__init__","title":"__init__","text":"<pre><code>def __init__(detail: Any = None,\n             headers: Optional[Dict[str, Any]] = None,\n             **extra_params: Any) -&gt; None\n</code></pre> <p>[view_source]</p> <p>Instances can be initialized with a set of extra params.</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-generichttpexception","title":"Class GenericHTTPException","text":"<pre><code>class GenericHTTPException(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>HTTP exception with extra data</p> <p></p> <p></p>"},{"location":"api/exceptions/#__init___1","title":"__init__","text":"<pre><code>def __init__(status_code: int,\n             detail: Any = None,\n             headers: Optional[Dict[str, Any]] = None,\n             **extra_params: Any) -&gt; None\n</code></pre> <p>[view_source]</p> <p>Used to raise custom exceptions with extra params.</p> <p>Arguments:</p> <ul> <li><code>status_code</code> int - Exception status code.</li> <li><code>detail</code> Any, optional - Error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - Error response data. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-badrequest","title":"Class BadRequest","text":"<pre><code>class BadRequest(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 400</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-unauthorized","title":"Class Unauthorized","text":"<pre><code>class Unauthorized(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 401</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-forbidden","title":"Class Forbidden","text":"<pre><code>class Forbidden(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 403</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-notfound","title":"Class NotFound","text":"<pre><code>class NotFound(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 404</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-methodnotallowed","title":"Class MethodNotAllowed","text":"<pre><code>class MethodNotAllowed(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 405</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-conflict","title":"Class Conflict","text":"<pre><code>class Conflict(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 409</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-gone","title":"Class Gone","text":"<pre><code>class Gone(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 410</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-unprocessableentity","title":"Class UnprocessableEntity","text":"<pre><code>class UnprocessableEntity(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 422</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul> <p></p> <p></p>"},{"location":"api/exceptions/#class-internalservererror","title":"Class InternalServerError","text":"<pre><code>class InternalServerError(BaseGenericHTTPException)\n</code></pre> <p>[view_source]</p> <p>Raises with HTTP status 500</p> <p>Arguments:</p> <ul> <li><code>detail</code> Any, optional - The error response content. Defaults to None.</li> <li><code>headers</code> Optional[Dict[str, Any]], optional - A set of headers to be returned in the response. Defaults to None.</li> </ul>"},{"location":"api/helpers/","title":"Helpers (<code>fastapi_responseschema.helpers</code>)","text":""},{"location":"api/helpers/#wrap_error_responses","title":"wrap_error_responses","text":"<pre><code>def wrap_error_responses(\n        app: FastAPI,\n        error_response_schema: Type[AbstractResponseSchema]) -&gt; FastAPI\n</code></pre> <p>[view_source]</p> <p>Wraps all exception handlers with the provided response schema.</p> <p>Arguments:</p> <ul> <li><code>app</code> FastAPI - A FastAPI application instance.</li> <li><code>error_response_schema</code> Type[AbstractResponseSchema] - Response schema wrapper model.</li> </ul> <p>Returns:</p> <ul> <li><code>FastAPI</code> - The application instance</li> </ul> <p></p> <p></p>"},{"location":"api/helpers/#wrap_app_responses","title":"wrap_app_responses","text":"<pre><code>def wrap_app_responses(app: FastAPI,\n                       route_class: Type[SchemaAPIRoute]) -&gt; FastAPI\n</code></pre> <p>[view_source]</p> <p>Wraps all app defaults responses</p> <p>Arguments:</p> <ul> <li><code>app</code> FastAPI - A FastAPI application instance.</li> <li><code>route_class</code> Type[SchemaAPIRoute] - The SchemaAPIRoute with your response schemas.</li> </ul> <p>Returns:</p> <ul> <li><code>FastAPI</code> - The application instance.</li> </ul>"},{"location":"api/interfaces/","title":"Interfaces (<code>fastapi_responseschema.interfaces</code>)","text":""},{"location":"api/interfaces/#class-abstractresponseschema","title":"Class AbstractResponseSchema","text":"<pre><code>class AbstractResponseSchema(PydanticGenericModel, Generic[T], ABC)\n</code></pre> <p>[view_source]</p> <p>Abstract generic model for building response schema interfaces.</p> <p></p> <p></p>"},{"location":"api/interfaces/#from_api_route","title":"from_api_route","text":"<pre><code>@classmethod\n@abstractmethod\ndef from_api_route(\n        cls: Type[TResponseSchema],\n        content: T,\n        path: str,\n        status_code: int,\n        response_model: Optional[Type[BaseModel]] = None,\n        tags: Optional[List[str]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        deprecated: Optional[bool] = None,\n        name: Optional[str] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr,\n                                               DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr,\n                                               DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Optional[Type[Response]] = None,\n        **extra_params: Any) -&gt; TResponseSchema\n</code></pre> <p>[view_source]</p> <p>Builds an instance of response model from an API Route constructor. This method must be overridden by subclasses.</p> <p>Arguments:</p> <ul> <li><code>content</code> Any - The response content.</li> <li><code>path</code> str - Response path info.</li> <li><code>status_code</code> int - response status code.</li> <li><code>response_model</code> Optional[Type[BaseModel]], optional - The route response model. Defaults to None.</li> <li><code>tags</code> Optional[List[str]], optional - OpenAPI Tags configured in the API Route. Defaults to None.</li> <li><code>summary</code> Optional[str], optional - OpenAPI Summary. Defaults to None.</li> <li><code>description</code> Optional[str], optional - OpenAPI description. Defaults to None.</li> <li><code>response_description</code> str, optional - A string describing the response. Defaults to \"Successful Response\".</li> <li><code>deprecated</code> Optional[bool], optional - OpenAPI deprecation flag. Defaults to None.</li> <li><code>name</code> Optional[str], optional - Operation name. Defaults to None.</li> <li><code>methods</code> Optional[Union[Set[str], List[str]]], optional - supoported methods. Defaults to None.</li> <li><code>operation_id</code> Optional[str], optional - OpenAPI operation ID. Defaults to None.</li> <li><code>response_model_include</code> Optional[Union[SetIntStr, DictIntStrAny]], optional - <code>response_model</code> \\   Included fields. Defaults to None.</li> <li><code>response_model_exclude</code> Optional[Union[SetIntStr, DictIntStrAny]], optional - <code>response_model</code> \\   Excluded fields. Defaults to None.</li> <li><code>response_model_by_alias</code> bool, optional - Enable or disable field aliases in <code>response_model</code>. \\   Defaults to True.</li> <li><code>response_model_exclude_unset</code> bool, optional - excludes unset values in <code>response_model</code>. Defaults to False.</li> <li><code>response_model_exclude_defaults</code> bool, optional - excludes default values in <code>response_model</code>. Defaults to False.</li> <li><code>response_model_exclude_none</code> bool, optional - excludes None values in <code>response_model</code>. Defaults to False.</li> <li><code>include_in_schema</code> bool, optional - wether or not include this operation in the OpenAPI Schema. Defaults to True.</li> <li><code>response_class</code> Optional[Type[Response]], optional - FastaAPI/Starlette Response Class. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>TResponseSchema</code> - A ResponseSchema instance</li> </ul> <p></p> <p></p>"},{"location":"api/interfaces/#from_exception","title":"from_exception","text":"<pre><code>@classmethod\n@abstractmethod\ndef from_exception(cls: Type[TResponseSchema],\n                   request: Request,\n                   reason: T,\n                   status_code: int,\n                   headers: Optional[dict] = None,\n                   **extra_params: Any) -&gt; TResponseSchema\n</code></pre> <p>[view_source]</p> <p>Builds a ResponseSchema instance from an exception. This method must be overridden by subclasses.</p> <p>Arguments:</p> <ul> <li><code>request</code> Request - A FastaAPI/Starlette Request.</li> <li><code>reason</code> str - The <code>Exception</code> description or response data.</li> <li><code>status_code</code> int - the response status code.</li> <li><code>headers</code> dict - the response_headers</li> </ul> <p>Returns:</p> <ul> <li><code>TResponseSchema</code> - A ResponseSchema instance</li> </ul> <p></p> <p></p>"},{"location":"api/interfaces/#from_exception_handler","title":"from_exception_handler","text":"<pre><code>@classmethod\ndef from_exception_handler(\n    cls: Type[TResponseSchema], request: Request,\n    exception: Union[RequestValidationError, StarletteHTTPException,\n                     FastAPIHTTPException, BaseGenericHTTPException]\n) -&gt; TResponseSchema\n</code></pre> <p>[view_source]</p> <p>Used in exception handlers to build a ResponseSchema instance. This method should not be overridden by subclasses.</p> <p>Arguments:</p> <ul> <li><code>request</code> Request - A FastaAPI/Starlette Request.</li> <li><code>exception</code> Union[RequestValidationError, StarletteHTTPException, FastAPIHTTPException, BaseGenericHTTPException] - The instantiated raised exception.</li> </ul> <p>Returns:</p> <ul> <li><code>TResponseSchema</code> - A ResponseSchema instance</li> </ul> <p></p> <p></p>"},{"location":"api/interfaces/#class-responsewithmetadata","title":"Class ResponseWithMetadata","text":"<pre><code>class ResponseWithMetadata(NamedTuple)\n</code></pre> <p>[view_source]</p> <p>This Interface wraps the response content with the additional metadata</p> <p>Arguments:</p> <ul> <li><code>metadata</code> dict - A dictionary containing the metadata fields.</li> <li><code>response_content</code> Optional[Any] - The content of the response. Default to None.</li> </ul>"},{"location":"api/pagination-integration/","title":"Pagination Integration (<code>fastapi_responseschema.integrations.pagination</code>)","text":""},{"location":"api/pagination-integration/#class-abstractpagedresponseschema","title":"Class AbstractPagedResponseSchema","text":"<pre><code>class AbstractPagedResponseSchema(AbstractPage[T], AbstractResponseSchema[T],\n                                  Generic[T])\n</code></pre> <p>[view_source]</p> <p>Abstract generic model for building response schema interfaces with pagination logic.</p> <p></p> <p></p>"},{"location":"api/pagination-integration/#class-pagedschemaapiroute","title":"Class PagedSchemaAPIRoute","text":"<pre><code>class PagedSchemaAPIRoute(SchemaAPIRoute)\n</code></pre> <p>[view_source]</p> <p>A SchemaAPIRoute class with pagination support. Must be subclassed setting at least SchemaAPIRoute.response_model.</p> <p>Usage:</p> <pre><code>from typing import Generic, TypeVar\nfrom fastapi_responseschema.integrations.pagination import AbstractPagedResponseSchema\n\nT = TypeVar(\"T\")\nclass MyResponseSchema(AbstractPagedResponseSchema[T], Generic[T]):\n    ...\n\nclass MyAPIRoute(SchemaPagedAPIRoute):\n    response_schema = MyResponseSchema\n    paged_response_schema = MyResponseSchema\n\nfrom fastapi import APIRouter\n\nrouter = APIRouter(route_class=MyAPIRoute)\n</code></pre> <p></p> <p></p>"},{"location":"api/pagination-integration/#class-paginationmetadata","title":"Class PaginationMetadata","text":"<pre><code>class PaginationMetadata(BaseModel)\n</code></pre> <p>[view_source]</p> <p>Pagination metadata model for pagination info.</p> <p>Arguments:</p> <ul> <li><code>total</code> int - Total number of items.</li> <li><code>page_size</code> int - Number of items per page.</li> <li><code>page</code> int - Page number.</li> <li><code>links</code> dict - Object containing pagination links.</li> </ul> <p></p> <p></p>"},{"location":"api/pagination-integration/#from_abstract_page_create","title":"from_abstract_page_create","text":"<pre><code>@classmethod\ndef from_abstract_page_create(cls, total: int,\n                              params: SupportedParams) -&gt; \"PaginationMetadata\"\n</code></pre> <p>[view_source]</p> <p>Create pagination metadata from an abstract page.</p> <p>Arguments:</p> <ul> <li><code>total</code> int - Total number of items.</li> <li><code>params</code> SupportedParams - A FastaAPI Pagination Params instance.</li> </ul> <p>Returns:</p> <ul> <li><code>PaginationMetadata</code> - PaginationMetadata instance</li> </ul> <p></p> <p></p>"},{"location":"api/pagination-integration/#class-paginationparams","title":"Class PaginationParams","text":"<pre><code>class PaginationParams(BaseModel, AbstractParams)\n</code></pre> <p>[view_source]</p> <p>Pagination Querystring parameters</p> <p>Arguments:</p> <ul> <li><code>page</code> int - The page number.</li> <li><code>page_size</code> int - Number of items per page.</li> </ul>"},{"location":"api/routing/","title":"Exceptions (<code>fastapi_responseschema.routing</code>)","text":""},{"location":"api/routing/#class-schemaapiroute","title":"Class SchemaAPIRoute","text":"<pre><code>class SchemaAPIRoute(APIRoute)\n</code></pre> <p>[view_source]</p> <p>An APIRoute class to wrap response_model(s) with a ResponseSchema Must be subclassed setting at least SchemaAPIRoute.response_model.</p> <p>Usage:</p> <pre><code>from typing import Generic, TypeVar\nfrom fastapi_responseschema.interfaces import AbstractResponseSchema\n\nT = TypeVar(\"T\")\nclass MyResponseSchema(AbstractResponseSchema[T], Generic[T]):\n    ...\n\nclass MyAPIRoute(SchemaAPIRoute):\n    response_schema = MyResponseSchema\n\nfrom fastapi import APIRouter\n\nrouter = APIRouter(route_class=MyAPIRoute)\n</code></pre> <p></p> <p></p>"},{"location":"api/routing/#is_error_state","title":"is_error_state","text":"<pre><code>def is_error_state(status_code: Optional[int] = None) -&gt; bool\n</code></pre> <p>[view_source]</p> <p>Handles the error_state for the operation evaluating the status_code. This method gets called internally and can be overridden to modify the error state of the operation.</p> <p>Arguments:</p> <ul> <li><code>status_code</code> Optional[int], optional - Operation status code. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - wether or not the operation returns an error</li> </ul> <p></p> <p></p>"},{"location":"api/routing/#get_wrapper_model","title":"get_wrapper_model","text":"<pre><code>def get_wrapper_model(\n        is_error: bool,\n        response_model: Type[Any]) -&gt; Type[AbstractResponseSchema[Any]]\n</code></pre> <p>[view_source]</p> <p>Implements the ResponseSchema selection logic. This method gets called internally and can be overridden to gain control over the ResponseSchema selection logic.</p> <p>Arguments:</p> <ul> <li><code>is_error</code> int - wheteher or not the operation returns an error.</li> <li><code>response_model</code> Type[Any] - response_model set for APIRoute.</li> </ul> <p>Returns:</p> <ul> <li><code>Type[AbstractResponseSchema[Any]]</code> - The ResponseSchema to wrap the response_model.</li> </ul> <p></p> <p></p>"},{"location":"api/routing/#override_response_model","title":"override_response_model","text":"<pre><code>def override_response_model(\n        wrapper_model: Type[AbstractResponseSchema[Any]],\n        response_model: Type[Any]) -&gt; Type[AbstractResponseSchema[Any]]\n</code></pre> <p>[view_source]</p> <p>Wraps the given response_model with the ResponseSchema. This method gets called internally and can be overridden to gain control over the response_model wrapping logic.</p> <p>Arguments:</p> <ul> <li><code>wrapper_model</code> Type[AbstractResponseSchema[Any]] - ResponseSchema Model</li> <li><code>response_model</code> Type[Any] - response_model set for APIRoute</li> <li><code>response_model_include</code> Optional[Union[SetIntStr, DictIntStrAny]], optional - Pydantic BaseModel include. Defaults to None.</li> <li><code>response_model_exclude</code> Optional[Union[SetIntStr, DictIntStrAny]], optional - Pydantic BaseModel exclude. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>Type[AbstractResponseSchema[Any]]</code> - The response_model wrapped in response_schema</li> </ul> <p></p> <p></p>"},{"location":"api/routing/#respond","title":"respond","text":"<pre><code>def respond(response_content: Optional[Any] = None,\n            **metadata: Any) -&gt; ResponseWithMetadata\n</code></pre> <p>[view_source]</p> <p>Returns the response content with optional metadata</p> <p>Arguments:</p> <ul> <li><code>response_content</code> Optional[Any], optional - Response Content. Defaults to None.</li> <li><code>**metadata</code> - Arbitrary metadata</li> </ul> <p>Returns:</p> <ul> <li><code>ResponseWithMetadata</code> - An intermediate data structure to add metadatato a ResponseSchema serialization</li> </ul>"},{"location":"guide/pagination-integration/","title":"Pagination Integration","text":"<p>FastAPI Response Schema integrates with FastAPI Pagination to handle pagination logic without reinventig the wheel.</p> <p>However, you can implement your own pagination utilities and integrate them with FastaAPI Response Schema.</p>"},{"location":"guide/pagination-integration/#pagedresponseschema","title":"PagedResponseSchema","text":"<p>A <code>PagedResponseSchema</code> is a generic that inherits from <code>fastapi_pagination.base.AbstractPage</code> and <code>fastapi_responseschema.interfaces.AbstractResponseSchema</code>.</p> <p>You can use this type of classes to handle pagination with a global response schema logic.</p> <pre><code>from typing import Sequence, TypeVar, Any, Generic, Union\nfrom fastapi_responseschema.integrations.pagination import AbstractPagedResponseSchema, PaginationMetadata, PagedSchemaAPIRoute, PaginationParams\n\n\nclass ResponseMetadata(BaseModel):\n    error: bool\n    message: Optional[str]\n    pagination: Optional[PaginationMetadata]\n\nT = TypeVar(\"T\")\n\nclass PagedResponseSchema(AbstractPagedResponseSchema[T], Generic[T]):\n    data: Union[Sequence[T], T]  # In case of error response we will pass a scalar type, a string or a dict\n    meta: ResponseMetadata\n\n    @classmethod\n    def create(\n            cls,\n            items: Sequence[T],\n            total: int,\n            params: PaginationParams,\n    ):  # This constructor gets called first and creates the FastAPI Pagination response model.\n    # For fields that are not present in this method signature just set some defaults,\n    # you will override them in the `from_api_route` constructor\n        return cls(\n            data=items,\n            meta=ResponseMetadata(\n                error=False,  \n                pagination=PaginationMetadata.from_abstract_page_create(total=total, params=params)\n            )\n        )\n\n    @classmethod\n    def from_exception(cls, reason: T, status_code: int, **others):\n        return cls(\n            data=reason,\n            meta=ResponseMetadata(error=status_code &gt;= 400, message=message)\n        )\n\n    @classmethod\n    def from_api_route(cls, content: Sequence[T], description: Optional[str] = None, **others): \n        # `content` parameter is the output from the `create` constructor.\n        return cls(error=status_code &gt;= 400, data=content.data, meta=content.meta)\n</code></pre>"},{"location":"guide/pagination-integration/#pagedschemaapiroute","title":"PagedSchemaAPIRoute","text":"<p>This is a SchemaAPIRoute that supports a <code>PagedResponseSchema</code> for paginated responses.</p> <p><pre><code>from fastapi_responseschema.integrations.pagination import PagedSchemaAPIRoute\n\n...\n\nclass PagedRoute(PagedSchemaAPIRoute):\n    response_schema = ResponseSchema\n    paged_response_schema = PagedResponseSchema\n</code></pre> This <code>PagedSchemaAPIRoute</code> can be integrated in fastapi as a <code>SchemaAPIRoute</code>.</p>"},{"location":"guide/pagination-integration/#usage","title":"Usage","text":"<p>The <code>AbstractPagedResponseSchema</code> class inherits from the <code>fastapi_pagination.bases.AbstractPage</code> and has to be used to configure the pagination correctly.</p> <pre><code>from pydantic import BaseModel\nfrom fastapi import FastAPI\nfrom fastapi_pagination import paginate, add_pagination\nfrom fastapi_responseschema import wrap_app_responses\nfrom .myroutes import PagedRoute  # the SchemaAPIRoute you defined\nfrom .myschemas import PagedResponseSchema  # the ResponseSchema you defined\n\napp = FastAPI()\nwrap_app_responses(app, route_class=PagedRoute)\n\nclass Bird(BaseModel):\n    id: int\n\n\n@app.get(\"/birds\", response_model=PagedResponseSchema[Bird])\ndef list_birds_w_pagination():\n    return paginate([Bird(id=n) for n in range(1, 3000)])\n\nadd_pagination(app)\n</code></pre>"},{"location":"guide/pagination-integration/#paginationparams-and-paginationmetadata","title":"<code>PaginationParams</code> and <code>PaginationMetadata</code>","text":"<p>Just take a look at the API documentation to learn more about.</p>"},{"location":"guide/routing/","title":"Routing","text":"<p>Once you have created your response schemas you can define the <code>SchemaAPIRoute</code> that will be used for your API set.</p> <p>A <code>SchemaAPIRoute</code> just inherits from <code>fastapi.routing.APIRoute</code>.</p> <pre><code>from fastapi_responseschema import SchemaAPIRoute\nfrom .myschemas import StandardResponseSchema  # The response schema you defined\n\nclass StandardAPIRoute(SchemaAPIRoute):\n    response_schema = StandardResponseSchema  # This attribute is required\n</code></pre> <p>If you want to handle different schemas for success and error responses you can set the error response schema.</p> <pre><code>from fastapi_responseschema import SchemaAPIRoute\nfrom .myschemas import OKResponseSchema, KOResponseSchema   # The response schemas you defined\n\nclass StandardAPIRoute(SchemaAPIRoute):\n    response_schema = OKResponseSchema  # This attribute is required\n    error_response_schema = KOResponseSchema  # If not set defaults to `SchemaAPIRoute.response_schema`\n</code></pre>"},{"location":"guide/routing/#integrating-in-your-api","title":"Integrating in your API","text":"<p>You can set the defined <code>SchemaAPIRoute</code> in you FastAPI application.</p> <pre><code>from fastapi import FastAPI\nfrom .myroutes import StandardAPIRoute  # the SchemaAPIRoute you defined\n\napp = FastAPI()\n\napp.router.route_class = StandardAPIRoute\n\n@app.get(\"/\")\ndef just_a_route():\n    return {\"message\": \"It Works!\"}\n</code></pre> <p>You can even integrate the schema api route in <code>APIRouter</code>.</p> <pre><code>from pydantic import BaseModel\nfrom fastapi import APIRouter\nfrom .myroutes import StandardAPIRoute  # the SchemaAPIRoute you defined\n\nrouter = APIRouter(route_class=StandardAPIRoute)\n\nclass ParrotMessage(BaseModel):\n    message: str\n\n\n@router.post(\"/parrot\")\ndef repeat(body: ParrotMessage):\n    return {\"parrot_says\": body.message}\n</code></pre>"},{"location":"guide/routing/#handling-errors","title":"Handling errors","text":"<p>You can wrap all error responses with the <code>wrap_error_responses</code> helper.</p> <pre><code>from fastapi import FastAPI\nfrom fastapi_responseschema import wrap_error_responses\nfrom .myroutes import StandardAPIRoute\nfrom .myschemas import KOResponseSchema\n\napp = FastAPI()\n\napp.router.route_class = StandardAPIRoute\nwrap_error_responses(app, error_response_schema=KOResponseSchema)\n\n@app.get(\"/\")\ndef just_a_route():\n    return {\"message\": \"It Works!\"}\n</code></pre>"},{"location":"guide/routing/#handling-errors-and-override-application-apiroute","title":"Handling errors and override application APIRoute","text":"<p>The same functionality as: <pre><code>...\n\napp.router.route_class = StandardAPIRoute\nwrap_error_responses(app, error_response_schema=KOResponseSchema)\n\n...\n</code></pre></p> <p>Can be achieved with <code>wrap_app_responses</code>: <pre><code>from fastapi import FastAPI\nfrom fastapi_responseschema import wrap_app_responses\nfrom .myroutes import StandardAPIRoute  # the SchemaAPIRoute you defined\n\napp = FastAPI()\n\nwrap_app_responses(app, route_class=StandardAPIRoute)\n\n@app.get(\"/\")\ndef just_a_route():\n    return {\"message\": \"It Works!\"}\n</code></pre></p> <p>You still need to configure the route class for every <code>fastapi.APIRouter</code>.</p>"},{"location":"guide/routing/#about-response_model_exclude-response_model_include-and-others-response_model_-parametrs","title":"About <code>response_model_exclude</code>, <code>response_model_include</code> and others <code>response_model_*</code> parametrs","text":"<p>When using response fields modifiers on-the-fly. you must consider that the final output of <code>response_model</code> will be wrapped by the configured ResponseSchema.</p> <p>For this snippet: <pre><code>from typing import TypeVar, Generic\nfrom pydantic import BaseModel\nfrom fastapi import APIRouter\nfrom fastapi_responseschema import AbstractResponseSchema, SchemaAPIRoute\n\nT = TypeVar(\"T\")\n\nclass ResponseSchema(AbstractResponseSchema[T], Generic[T]):\n    data: T\n    error: bool\n    message: Optional[str]\n\n    ... # constructors etc.\n\nclass Item(BaseModel):\n    id: int\n    name: str\n    additional_desc: Optional[str]\n\nclass MainAPIRoute(SchemaAPIRoute):\n    response_schema = ResponseSchema\n\nrouter = APIRouter(route_class=MainAPIRoute)\n\n@router.get(\"/item\", response_model=Item)\ndef show_item():\n    return {\"id\": 11, \"name\": \"Just a Teapot!\"}\n</code></pre></p> <p>The resulting response payload of <code>GET /items</code> will be: <pre><code>{\n    \"data\": {\n        \"id\": 11, \n        \"name\": \"Just a Teapot!\",\n        \"additional_desc\": null\n    },\n    \"error\": false,\n    \"message\": null\n}\n</code></pre></p> <p>When applying the <code>response_model_exclude</code> and <code>additional_model_include</code> for the <code>response_model</code> remeber to consider the nested output.</p> <p>For Example: <pre><code>...\n\n@router.get(\"/item\", response_model=Item, response_model_exclude={\"data\": {\"name\"}})  # Exclusion of nested fields\ndef show_item():\n    return {\"id\": 11, \"name\": \"Just a Teapot!\"}\n</code></pre> Returns:</p> <pre><code>{\n    \"data\": {\n        \"id\": 11, \n        \"additional_desc\": null\n    },\n    \"error\": false,\n    \"message\": null\n}\n</code></pre> <p>When you use <code>response_model_exclude_none</code> and similar parameters the configuration will be applyed to all the response schema.</p> <p>For example: <pre><code>...\n\n@router.get(\"/item\", response_model=Item, response_model_exclude_none=True)  # Exclusion of nested fields\ndef show_item():\n    return {\"id\": 11, \"name\": \"Just a Teapot!\"}\n</code></pre> Returns:</p> <pre><code>{\n    \"data\": {\n        \"id\": 11, \n        \"name\": \"Just a Teapot!\"\n    },\n    \"error\": false\n}\n</code></pre> <p>To modify the response content you should prefer the definition of dedicated models.</p>"},{"location":"guide/schemas/","title":"Schemas","text":"<p>Response schemas heavily rely on the concept of pydantic GenericModel.</p> <p>In this way <code>response_model</code> can be wrapped by the <code>ResponseSchema</code> in the fastapi operation.</p> <p><code>ResponseSchema</code> will wrap your response ONLY if you configured a <code>response_model</code> in your route operation.</p> <p>In order to create a response schema you need to make the class a Generic type.  <pre><code>from typing import TypeVar, Generic\nfrom fastapi_responseschema import AbstractResponseSchema\n\nT = TypeVar(\"T\")\n\n\nclass ResponseSchema(AbstractResponseSchema[T], Generic[T]):\n    ...\n</code></pre></p>"},{"location":"guide/schemas/#constructors","title":"Constructors","text":"<p>When creating a response schema, constructors must be defined in subclass to ensure that the final response model gets correctly created and additional metadata can be passed to the final response.</p>"},{"location":"guide/schemas/#abstractresponseschemafrom_exception","title":"<code>AbstractResponseSchema.from_exception</code>","text":"<p>This constructor wraps the final response from an exception handler. You can view the full parameter list here.</p>"},{"location":"guide/schemas/#abstractresponseschemafrom_api_route","title":"<code>AbstractResponseSchema.from_api_route</code>","text":"<p>This constructor wraps the final response when initializing an APIRoute. You can view the full parameter list here.</p> <pre><code>from typing import TypeVar, Generic\nfrom fastapi_responseschema import AbstractResponseSchema\n\nT = TypeVar(\"T\")\n\n\nclass ResponseSchema(AbstractResponseSchema[T], Generic[T]):\n    data: T\n    error: bool\n    message: str\n\n    @classmethod\n    def from_exception(cls, reason: T, status_code: int, message: str = \"Error\", **others):  # from an exception handler \n        return cls(\n            data=reason,\n            error=status_code &gt;= 400, \n            message=message\n        )\n\n    @classmethod\n    def from_api_route(\n        cls, content: T, status_code: int, description: Optional[str] = None, **others\n    ):  # from an api route\n        return cls(\n            data=content,\n            error=status_code &gt;= 400, \n            description=description\n        )\n</code></pre> <p>Multiple response schemas can be built and composed in <code>SchemaAPIRoute</code> subclasses.</p>"},{"location":"guide/utilities/","title":"Utilities","text":""},{"location":"guide/utilities/#additional-metadata-in-the-resulting-response-schema","title":"Additional metadata in the resulting response schema","text":"<p>If you need to add fields to the response schema that are not supported by <code>AbstractResponseSchema.from_api_route</code>, you can use the <code>respond</code> function.</p> <pre><code># schemas.py file\nfrom typing import TypeVar, Generic\nfrom fastapi_responseschema import AbstractResponseSchema\n\nT = TypeVar(\"T\")\n\n\nclass ResponseSchema(AbstractResponseSchema[T], Generic[T]):\n    data: T\n    error: bool\n    code: str  # From a `result_code` field, not natively supported by constructors\n\n    @classmethod\n    def from_exception(cls, reason: T, status_code: int, result_code: str = \"Error\", **others):\n        return cls(\n            data=reason,\n            error=status_code &gt;= 400, \n            code=result_code\n        )\n\n    @classmethod\n    def from_api_route(\n        cls, content: T, status_code: int, result_code: Optional[str] = None, **others\n    ):\n        return cls(\n            data=content,\n            error=status_code &gt;= 400, \n            code=result_code\n        )\n\n...\n\n# api.py file\nfrom fastapi import APIRouter\nfrom fastapi_responseschema import respond\nfrom .schemas import StandardAPIRoute  # the SchemaAPIRoute you defined\n\nrouter = APIRouter(route_class=StandardAPIRoute)\n\nclass ParrotMessage(BaseModel):\n    message: str\n\n\n@router.post(\"/parrot\")\ndef repeat(body: ParrotMessage):\n    return respond({\"parrot_says\": body.message}, result_code=\"OK_PARROT_HEALTHY\")\n</code></pre> <p>In a similar way, for fields that are not supported in <code>AbstractResponseSchema.from_exception</code> you can raise an exception with metadata: <pre><code>from fastapi_responseschema.exceptions import GenericHTTPException\n...\n\n@router.get(\"/faulty\")\ndef repeat():\n    raise GenericHTTPException(status_code=405, detail=\"This is a faulty service\", result_code=\"KO_NOT_SUPPORTED\")\n</code></pre></p>"},{"location":"guide/utilities/#exceptions","title":"Exceptions","text":"<p>When developing a backend service usually we keep raising the same few excpetions with the same status code. You can use the <code>exceptions</code> module to reduce a little bit the boilerplate code.</p> <pre><code>from fastapi_responseschema.exceptions import MethodNotAllowed, Gone, NotFound\n\n...\n\n@router.get(\"/faulty\")\ndef repeat():\n    raise MethodNotAllowed(detail=\"This is a faulty service\", result_code=\"KO_NOT_SUPPORTED\")\n\n@router.get(\"/ghost\")\ndef ghost():\n    raise Gone(detail=\"This resource is gone, forever.\", result_code=\"KO_CREEPY_GONE\")\n\n@router.get(\"/nope\")\ndef ghost():\n    raise NotFound(detail=\"Nope man, can't help you\", result_code=\"KO_NOT_FOUND\")\n</code></pre>"}]}